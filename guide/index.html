
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>ノード及びコンポーネントの概要 | Grimoire.js</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="GOML概要Grimoire.jsの仕組みを理解するには、GOMLがどのように処理され、ノードやコンポーネントが構築されるのか、また属性がどのようにコンポーネントに割り当てられるのかを理解しなければなりません。この仕組みはXMLに準拠した記法であるGOMLであるがゆえに見た目上HTMLに非常に近いものとなっていますが、より一貫した思想を持って作成されています。
GOMLにおけるノード1234567">
<meta property="og:type" content="website">
<meta property="og:title" content="ノード及びコンポーネントの概要">
<meta property="og:url" content="http://grimoire.gl/guide/index.html">
<meta property="og:site_name" content="Grimoire.js">
<meta property="og:description" content="GOML概要Grimoire.jsの仕組みを理解するには、GOMLがどのように処理され、ノードやコンポーネントが構築されるのか、また属性がどのようにコンポーネントに割り当てられるのかを理解しなければなりません。この仕組みはXMLに準拠した記法であるGOMLであるがゆえに見た目上HTMLに非常に近いものとなっていますが、より一貫した思想を持って作成されています。
GOMLにおけるノード1234567">
<meta property="og:updated_time" content="2016-08-01T10:36:12.198Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ノード及びコンポーネントの概要">
<meta name="twitter:description" content="GOML概要Grimoire.jsの仕組みを理解するには、GOMLがどのように処理され、ノードやコンポーネントが構築されるのか、また属性がどのようにコンポーネントに割り当てられるのかを理解しなければなりません。この仕組みはXMLに準拠した記法であるGOMLであるがゆえに見た目上HTMLに非常に近いものとなっていますが、より一貫した思想を持って作成されています。
GOMLにおけるノード1234567">
  
    <link rel="alternate" href="/atom.xml" title="Grimoire.js" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-80429415-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


  <script type="text/javascript">
    var classCallCheck=function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")},Target=function e(){classCallCheck(this,e)};Target.extensions=["ANGLE_instanced_arrays","EXT_blend_minmax","EXT_color_buffer_half_float","EXT_disjoint_timer_query","EXT_frag_depth","EXT_sRGB","EXT_shader_texture_lod","EXT_texture_filter_anisotropic","OES_element_index_uint","OES_standard_derivatives","OES_texture_float","OES_texture_float_linear","OES_texture_half_float","OES_texture_half_float_linear","OES_vertex_array_object","WEBGL_color_buffer_float","WEBGL_compressed_texture_atc","WEBGL_compressed_texture_etc1","WEBGL_compressed_texture_pvrtc","WEBGL_compressed_texture_s3tc","WEBGL_debug_renderer_info","WEBGL_debug_shaders","WEBGL_depth_texture","WEBGL_draw_buffers","WEBGL_lose_context"],Target.parameters=["MAX_COMBINED_TEXTURE_IMAGE_UNITS","MAX_CUBE_MAP_TEXTURE_SIZE","MAX_FRAGMENT_UNIFORM_VECTORS","MAX_RENDERBUFFER_SIZE","MAX_TEXTURE_IMAGE_UNITS","MAX_TEXTURE_SIZE","MAX_VARYING_VECTORS","MAX_VERTEX_ATTRIBS","MAX_VERTEX_TEXTURE_IMAGE_UNITS","MAX_VERTEX_UNIFORM_VECTORS","MAX_VIEWPORT_DIMS"];var uuid=function t(){var t="",e=void 0,r=void 0;for(e=0;32>e;e++)r=16*Math.random()|0,8!==e&&12!==e&&16!==e&&20!==e||(t+="-"),t+=(12===e?4:16===e?3&r|8:r).toString(16);return t},Cookie=function r(){classCallCheck(this,r)};Cookie.set=function(e,t){window.document.cookie=e+"="+t},Cookie.get=function(e){var t=null,r=e+"=",_=document.cookie,a=_.indexOf(r);if(-1!==a){var o=a+r.length,n=_.indexOf(";",o);-1===n&&(n=_.length),t=decodeURIComponent(_.substring(o,n))}return t};var collector=function(){for(var e=document.createElement("canvas"),t=e.getContext("webgl"),r={},_=0;_<Target.extensions.length;_++)r[Target.extensions[_]]=null!==t.getExtension(Target.extensions[_]);var a=!1;if(null===t.getExtension("WEBGL_color_buffer_float")){var o=t.createFramebuffer(),n=t.createTexture();t.bindFramebuffer(t.FRAMEBUFFER,o),t.bindTexture(t.TEXTURE_2D,n),t.texImage2D(t.TEXTURE_2D,0,t.RGBA,1,1,0,t.RGBA,t.FLOAT,null),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,n,0),a=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE,t.deleteTexture(n),t.deleteFramebuffer(o)}else a=!0;a&&(r.WEBGL_color_buffer_float=a);for(var E={},s=0;s<Target.parameters.length;s++)if("MAX_VIEWPORT_DIMS"===Target.parameters[s]){var i=t.getParameter(t[Target.parameters[s]]);E[Target.parameters[s]+"_0"]=i[0],E[Target.parameters[s]+"_1"]=i[1]}else E[Target.parameters[s]]=t.getParameter(t[Target.parameters[s]]);var T=navigator.userAgent,l=null===Cookie.get("key")?uuid():Cookie.get("key");Cookie.set("key",l);var u={id:l,user:T,extensions:r,parameters:E,domain:document.domain},f=new XMLHttpRequest;f.open("POST","http://wglstat.grimoire.gl/record"),f.setRequestHeader("Content-Type","application/json"),f.send(JSON.stringify(u))};collector();
  </script>
</head>

<body>
  
    <header id="header">
  <a id="logo-wrap" href="/">
    <div id="logo-icon"></div>
    <div id="logo-font"></div>
  </a>
  <nav>
    <ul id="menu">
      <li><a href="/guide">Guide</a></li>
      <li><a href="/tips">Tips</a></li>
      <li><a href="/api">API</a></li>
      <li><a href="/">PlayGround</a></li>
      <li><a href="https://github.com/GrimoireGL/GrimoireJS">Github</a></li>
    </ul>
  </nav>
</header>

    <div id="main">
      
<div id="column-wrap">
  <aside id="sidebar">
  <div id="doc-title">GUIDE</div>
  <ul id="list">
    
      <li class="active">
        <a href="/guide/index.html">ノード及びコンポーネントの概要</a>
      </li>
    
  </ul>
</aside>

  <div id="content">
    <h1 id="content-title">ノード及びコンポーネントの概要</h1>
    <h1 id="GOML概要"><a href="#GOML概要" class="headerlink" title="GOML概要"></a>GOML概要</h1><p>Grimoire.jsの仕組みを理解するには、GOMLがどのように処理され、ノードやコンポーネントが構築されるのか、また属性がどのようにコンポーネントに割り当てられるのかを理解しなければなりません。<br>この仕組みはXMLに準拠した記法であるGOMLであるがゆえに見た目上HTMLに非常に近いものとなっていますが、より一貫した思想を持って作成されています。</p>
<h2 id="GOMLにおけるノード"><a href="#GOMLにおけるノード" class="headerlink" title="GOMLにおけるノード"></a>GOMLにおけるノード</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">goml</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">renderers</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">renderer</span> <span class="attr">id</span>=<span class="string">"main"</span> <span class="attr">camera</span>=<span class="string">".camera"</span>/&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">renderers</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">scenes</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">scene</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">camera</span> <span class="attr">class</span>=<span class="string">"camera"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">scene</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">scenes</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">goml</span>&gt;</span></div></pre></td></tr></table></figure>
<blockquote>
<p>例1: GOMLの例</p>
</blockquote>
<p>例えば、以上のような例をみるとGOMLにおけるノードとは<code>goml</code>、<code>renderers</code>、<code>renderer</code>、<code>scenes</code>、<code>scene</code>や<code>camera</code>になります。<br>どのようなノードであれ、<code>id</code>及び<code>class</code>を属性として持てます。</p>
<p>ノードは以下のような要素を持つデータ構造です。</p>
<ul>
<li>子要素(0個以上)</li>
<li>親要素(0または1個)</li>
<li>コンポーネント(0個以上)</li>
<li>DOMParserによりパースされた対応するElement</li>
</ul>
<p><strong>親要素</strong>と<strong>子要素</strong>は言うまでもなく、ただのノードのツリー構造を表すためのものにすぎません。</p>
<h3 id="コンポーネントの概説"><a href="#コンポーネントの概説" class="headerlink" title="コンポーネントの概説"></a>コンポーネントの概説</h3><p>ノードはコンポーネントを持ちます。コンポーネントはGrimoire.jsにおける一定の処理を行う単位になります。<br>コンポーネントはノードからAttributeあるいは属性と呼ばれる値を受け取り、それに合わせた処理を行います。<br><strong>この概念は基本的にゲームエンジンであるUnityに近い思想なので、これを理解しているとこの概念の理解は早いでしょう。</strong></p>
<blockquote>
<p>UnityにおけるコンポーネントとGrimoire.jsにおけるコンポーネントの違い</p>
<p>以下のような関係を考えるとGrimoire.jsのコンポーネントは理解しやすいです。</p>
<ul>
<li>UnityにおけるGameobjectはGOMLのノードにあたります。</li>
<li>UnityにおけるGameobjectのnameはノードのidにあたります。</li>
<li>UnityにおけるGameobjectのtagやlayerはノードのclassで実現できます。</li>
<li>UnityにおけるコンポーネントはGrimoire.jsにおけるコンポーネントと基本的に同義ですが、UnityはTransformerを必ず持っているのが条件に対して、Grimoire.jsではどのようなノードでも持っていると保証されるコンポーネントは存在しません。</li>
<li>つまり、ノードではあるが、シーン中に存在する(Unityにおけるヒエラルキー)に存在するとは限らないものが存在します。</li>
</ul>
</blockquote>
<p>例えば、sceneの子孫要素として取り得るノード(例えば<code>camera</code>等)は必ず<code>Transformer</code>コンポーネントを所持しています。<br>Transformerコンポーネントはシーン中のモデルの姿勢(= 平行移動変形 + 回転変形 + 拡大変形)を計算します。</p>
<p>そのため、Transformerコンポーネントは以下のような属性を受け取ります。</p>
<ul>
<li>position・・・座標(vector3型)</li>
<li>rotation・・・回転(rotation3型)</li>
<li>scale・・・拡大率(vector3型)</li>
</ul>
<p>属性は必ず型を持ちます。(型については後述します。)</p>
<h3 id="ノードの定義"><a href="#ノードの定義" class="headerlink" title="ノードの定義"></a>ノードの定義</h3><p>HTMLにおいては、近年のVirtual-DOMブームを除けば基本的にエンジニアが新たなHTMLタグを定義することはありません。<br>GOMLにおけるタグの定義は以下のような要素で成り立ちます。</p>
<ul>
<li>ノード名</li>
<li>デフォルトコンポーネントリスト</li>
<li>デフォルト値</li>
</ul>
<p>デフォルトコンポーネントとはそのノードをインスタンス化した際に自動でコンポーネントとしてそのノードに割り当てられるコンポーネントです。<br>例えば、<code>goml</code>ノードには以下のようなコンポーネントがデフォルトコンポーネントリストに含まれています。(これが全てではありません)</p>
<ul>
<li>CanvasInitiator・・・対象となる位置に<code>&lt;canvas&gt;</code>タグを配置し、<code>WebGLコンテキスト</code>を初期化するコンポーネント</li>
<li>LoopManager・・・レンダリングなどの処理のためにGrimoire.js中で行われるループを管理し、適切に更新を呼び出すためのコンポーネント</li>
<li>…etc</li>
</ul>
<p>通常、デフォルトコンポーネントリストが空なノードは何の役割も持ちません。新たなノードを作るということは、<strong>複数個のコンポーネントからなるノードがどう振る舞うか</strong>をノードのデフォルトノードのリストに追加することと同義になります。</p>
<p>ノードはデフォルト値の連想配列を同時に所持します。このデフォルト値はコンポーネントの属性に同名の属性があり、かつユーザーがGOML側から新たな値を指定しない場合に用いられる値です。</p>
<h3 id="コンポーネントの定義"><a href="#コンポーネントの定義" class="headerlink" title="コンポーネントの定義"></a>コンポーネントの定義</h3><p>Grimoire.jsにおけるコンポーネントの定義は以下のような要素を持ちます。</p>
<ul>
<li>コンポーネント名</li>
<li>属性のリスト</li>
<li>メソッドのリスト</li>
</ul>
<p>属性のリストとは、そのコンポーネントがどのような値を入力として受け取るかの、名称と型の連想配列です。</p>
<p>メソッドのリストとは、そのコンポーネントの振る舞いを記述するためのメソッドです。詳しくは次の”メッセージのブロードキャスト”をみるとより概要が把握できるでしょう。</p>
<h3 id="メッセージのブロードキャスト"><a href="#メッセージのブロードキャスト" class="headerlink" title="メッセージのブロードキャスト"></a>メッセージのブロードキャスト</h3><p>メッセージのブロードキャストはノードが持つ機能の一つです。あるノードにたいしてメッセージ”Update”を引数Xでブロードキャストするとは、あるノード及びその子孫全てにおいて、そのノードが持つコンポーネントの中に”Update”というメソッドがある場合これを引数Xを用いてこのメソッド呼びます。</p>
<p>例えば、ノードに対するブロードキャストは以下のような関数の定義になっています。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">GomlNode</span>#<span class="title">broadcastMessage</span>(<span class="params">layer:<span class="built_in">number</span>,message:<span class="built_in">string</span>,...args:<span class="built_in">any</span>[]</span>)</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">GomlNode</span>#<span class="title">broadcastMessage</span>(<span class="params">message:<span class="built_in">string</span>,...args:[]</span>)</span>;</div></pre></td></tr></table></figure>
<p>注) <code>X#A</code>とはクラスXにおけるインスタンスメソッドAを指すものとします。</p>
<p>上記の定義を見ればわかる通り、第一引数に数値を受け取ることがあります。この数値layerは非負の整数であり、layer番目までの子要素に対してメッセージを送ることを意味します。<br>このため、<code>broadcastMessage(1,&quot;Update&quot;,X)</code>は自分と自分の直下の子供の要素に対してのみ、Updateメソッドが存在する場合呼び出します。</p>
<p>このことからわかる通り、layerを省略してメッセージ名から記述を始めた際、つまり<code>broadcastMessage(&quot;Update&quot;,X)</code>を呼び出したような状況下においては、これは<code>broadcastMessage(Number.MAX_VAUE,&quot;Update&quot;,X)</code>と全く同値です。</p>
<p>また、自分自身のコンポーネントだけを対象とする<code>broadcastMessage(0,&quot;Update&quot;,X)</code>のエイリアスとして<code>sendMessage(&quot;Update&quot;,X)</code>が存在します。</p>
<p>Grimoire.jsにおける様々な処理はこのメッセージを利用して処理しています。</p>
<p>例えば、最初にScene内のUpdateが呼ばれるまで以下のようなメッセージのブロードキャストを通して初期化が行われます。</p>
<ol>
<li>GOMLの読み込みによってすべてのノードの構築が終了すると、GomlParserは”TreeInitialized”メッセージをルート要素にsendMessageします。</li>
<li><code>goml</code>ノード内にある<code>CanvasInitiator</code>がこのメッセージを受け取ると対象となるHTMLの位置に<code>&lt;canvas&gt;</code>を差し込みます。</li>
<li>初期状態で読み込まなければいけないGOMLがすべて読み込まれると、<code>treePrepare</code>メッセージをルート要素からbroadcastMessageします。</li>
<li>この際、<code>goml</code>要素内の<code>LoadManager</code>が<code>canvas</code>上にロード画面を表示します。</li>
<li>その他の初期ロード時なければならないリソースはこの際に<code>LoadManager</code>コンポーネントに対してリソースの読み込み終了のためのハンドラーを登録します。</li>
<li>すべてのハンドラーが解決されると、<code>LoadManager</code>は<code>goml</code>ノードの<code>LoopManager</code>コンポーネントに対してループを開始させます。</li>
<li>以降毎回のループで<code>scene</code>のルートから<code>LoopManager</code>が<code>broadcastMessage(&quot;Update&quot;)</code>を行います。</li>
</ol>
<h3 id="属性及び型"><a href="#属性及び型" class="headerlink" title="属性及び型"></a>属性及び型</h3><p>コンポーネントは属性を0個以上持つことが可能です。<br>属性は以下のようなデータ構造を持つものです。</p>
<ul>
<li>属性名</li>
<li>デフォルト値</li>
<li>型名</li>
</ul>
<p>各型に対して定義されている以下のようなインターフェースを満たす関数を<code>コンバーター</code>と言います。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">converter</span>(<span class="params">rawValue:<span class="built_in">any</span></span>):<span class="title">any</span></span>;</div></pre></td></tr></table></figure>
<p>通常、GOMLにより記述された属性は文字列として<code>converter</code>に渡され、コンポーネント内で利用する型に変換されます。<br>例えば、型に<code>vector3</code></p>
<h1 id="より発展的な内容"><a href="#より発展的な内容" class="headerlink" title="より発展的な内容"></a>より発展的な内容</h1><h3 id="ノードの継承"><a href="#ノードの継承" class="headerlink" title="ノードの継承"></a>ノードの継承</h3>
    <div id="edit-page">
      <a href="https://github.com/GrimoireGL/grimoire.gl/blob/master/source/guide/index.md" target="_blank">Edit this page on Github</a>
    </div>
  </div>
</div>

    </div>
  
</body>
</html>
